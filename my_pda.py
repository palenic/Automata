# -*- coding: utf-8 -*-
"""Pushdown automata
Provides the Pda class, extending the Fsa class to configure and run 
pushdown automata (PDA) and a parser function to parse .txt files into a 
Pda object.
"""

import my_fsa as fsa

class Pda(fsa.Fsa):
    """
    Create and use a pushdown automata object. 
    
    Attributes
    ----------
    states : list of string
        the states of the automaton.
    transitions : dict
        a dictionary with tuples (start_state, input, pile_read) as keys 
        and (end_state, output, pile_action) as value describing the 
        allowed transitions.
    current_state : string
        the current state of the automaton (initialized as initial_state 
        when run_pda is called).
    initial_state : string
        the initial state of the automaton.
    final_states : list of string
        the final states of the automaton.
    out : list of string
        the output generated by the execution (initialized as an empty list 
        when run_pda is called).
    pile : list of string
        the pile. The first slot is 'Z0' and marks the start of the pile.
    name : string
        a nickname for the automaton. The default is "".
    
    """
    def __init__(self, name=""):
        __doc__ = fsa.Fsa.__doc__
        super().__init__(name)
        self.pile = ["Z0"]
        
    def add_transition(self, start, inp, current_cell, end, pile_action, out):
        """
        Add a transition between two states to the automaton. If an invalid 
        transition is given it will not be added to the automaton.

        Parameters
        ----------
        start : string
            The first state. Must be part of the allowed states (states 
            attribute). 
        inp : string
            The input that triggers the transition.
        current_cell: string
            The character in the pile that triggers the transition.
        end : string
            The next state. Must be part of the allowed states (states 
            attribute).
        pile_action : string
            Any character to append it to the pile, del to delete last 
            character, nothing to keep pile as is
        out : string
            What to write in the output (for transducers). If empty, 
            nothing will be written.

        Returns
        -------
        None.

        """
        #(init, input): final)
        if start not in self.states or end not in self.states:
            print("Invalid start or end state")
        else: 
            self.transitions[(start, inp, current_cell)] = (end, pile_action, out)
    
    def run_fsa(self, inp = ""):
        """
        Masked from Fsa, not useful
        """
        pass
    
    def run_pda(self, inp = None):
        """
        Runs automaton on the provided input string. Ends if the automaton 
        does not have a start state, one or more final states and one or 
        more transitions, or if no input is given.  

        Parameters
        ----------
        inp : TYPE, optional
            DESCRIPTION. The default is None.

        Returns
        -------
        int
            -2 if the automaton is invalid or no input is given;
            -1 if input was not accepted by the automaton;
            0 if input was accepted.

        """    
        if self.check_automaton() == False:
            return -2
        if inp is None:
            print("Please provide an input string")
            return -2
        
        print("Running automaton",self.name,"on input: ", inp)
        self.pile=["Z0"]
        self.out=[]
        self.current_state = self.initial_state
        i = 0
        L = len(inp)
        while i<L:
            try:
                cmd = inp[i]
                current_tr = self.transitions[(self.current_state, cmd, self.pile[-1])]
                i += 1
            except KeyError:
                try:
                    #if there is no transition defined for output and pile, try epsilon move
                    current_tr = self.transitions[(self.current_state, "eps", self.pile[-1])]
                except KeyError:
                    #if there is no transition and no epsilon move, we cannot move from this
                    #state but the string is not finished. So it must be unacceptable
                    break
            self.current_state = current_tr[0]
            self.out.append(current_tr[2]) 
            if current_tr[1] == "del":
                del self.pile[-1]
            elif current_tr[1] == "":
                pass
            else:
                self.pile.append(current_tr[1])
        # try epsilon moves once the string is over
        count = 0
        while True:
            try:
                eps_move = self.transitions[(self.current_state, "eps", self.pile[-1])]
                if self.current_state == eps_move[0]:
                    count += 1
                self.current_state = eps_move[0]
                if eps_move[1] == "del":
                    del self.pile[-1]
                elif eps_move[1] == "":
                    pass
                else:
                    self.pile.append(eps_move[1])
                self.out.append(eps_move[2]) 
                if count > 20:
                    print("You might have entered a cycle. Cycles of epsilon-moves do not add to the expressivity of the automaton. Ending execution")
                    break
            except KeyError:
                break
            
        print("the final state is: ",self.current_state)
        print("output: ", "".join(self.out))
        if (self.current_state in self.final_states) and (i == L):
            print("The automaton accepts this string")
            return 0
        else:
            print("The automaton does not accept this string")
            return -1


def pda_from_txt(file, name=""):
    """
    Builds a PDA from a configuration file in txt format, structured 
    as follows:
        first line: all the states separates by commas
        second line: initial state
        third line: final states separated by commas
        following lines: transitions with format: 
            start_state, input, pile_read, end_state, pile_action, output
    
    input: can be eps to specify an epsilon-move
    pile_action: any character to append it to the pile, del to delete 
        last character, nothing to keep pile as is
    
    IMPORTANT: spaces are not stripped

    Parameters
    ----------
    file : string
        path to the .txt file.
    name : string, optional
        Nickname for the automaton. The default is "".

    Returns
    -------
    automaton : Pda
        An object of class Pda containing the automaton specified by the 
        states and transitions in the configuration file.

    """
    automaton = Pda(name)
    automaton = fsa.from_txt_helper(automaton, file)
    with open(file) as f:
        for line in f.readlines()[3:]:
            tr = line.strip().split(",")
            automaton.add_transition(tr[0],tr[1],tr[2],tr[3],tr[4],tr[5])
        return automaton