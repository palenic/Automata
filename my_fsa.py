# -*- coding: utf-8 -*-
"""Finite state automata
Provides the Fsa class to configure and run finite state automata (FSA) 
and a parser function to parse .txt files into a Fsa object.
"""
class Fsa:
    """
    Create and use a finite state automata object. 
    
    Attributes
    ----------
    states : list of string
        the states of the automaton.
    transitions : dict
        a dictionary with tuples (start_state, input) as keys and 
        (end_state, output) as value describing the allowed transitions.
    current_state : string
        the current state of the automaton (initialized as initial_state when run_fsa is called).
    initial_state : string
        the initial state of the automaton.
    final_states : list of string
        the final states of the automaton.
    out : list of string
        the output generated by the execution (initialized as an empty list when run_fsa is called).
    name : string
        a nickname for the automaton. The default is "".
    
    """
    def __init__(self,name=""):
        """
        Initialize empty automaton.
        
        Parameters
        ----------
        name : string, optional
            A nickname for the automaton. The default is "".

        Returns
        -------
        None.

        """
        self.states = []
        self.transitions = {}
        self.current_state = None
        self.initial_state = None
        self.final_states = []
        self.out = []
        self.name = name
        
    def define_start(self, start_state):
        """
        Set starting state for the automaton. 

        Parameters
        ----------
        start_state : string
            The start state. Must be part of the allowed states (states attribute).

        Returns
        -------
        None.

        """
        if start_state not in self.states:
            print(start_state, "is not part of the automaton allowed states, so it can't be used as initial state")
        else:
            self.initial_state = start_state
            
    def define_end(self, end_states):
        """
        Set final state/s for the automaton.

        Parameters
        ----------
        end_states : list of strings
            A list of allowed end states. Must be part of the allowed 
            states (states attribute). Can also be of length 1.

        Returns
        -------
        None.

        """
        for i in end_states:
            if i not in self.states:
                print(i, "is not part of the automaton allowed states, so it can't be used as final state")
            else:
                self.final_states.append(i)
            
    def add_states(self, states):
        """
        Add a list of states to the automaton.

        Parameters
        ----------
        states : list of strings
            A list of allowed states for the automaton. Can also be of length 1.

        Returns
        -------
        None.

        """
        for i in states:
            self.add_state(i)
        
    def add_state(self, state):
        """
        Add a single state to the automaton.

        Parameters
        ----------
        state : string
            A single state for the automaton.

        Returns
        -------
        None.

        """
        self.states.append(state)
            
    def add_transition(self, start, inp, end, out):
        """
        Add a transition between two states to the automaton. If an invalid 
        transition is given it will not be added to the automaton.

        Parameters
        ----------
        start : string
            The first state. Must be part of the allowed states (states attribute). 
        inp : string
            The input that triggers the transition.
        end : string
            The next state. Must be part of the allowed states (states attribute).
        out : string
            What to write in the output (for transducers). If empty, 
            nothing will be written.

        Returns
        -------
        None.

        """
        #(init, input): final)
        if start not in self.states or end not in self.states:
            print("Invalid start or end state")
        else: 
            self.transitions[(start,inp)] = (end, out)
    
    def check_automaton(self):
        """
        Helper function for run_fsa and my_pda.run_pda. Check that the 
        automaton has a start state, one or more final states and one or 
        more transitions.

        Returns
        -------
        bool
            True if all conditions are respected, False otherwise.

        """
        if self.initial_state is None:
            print("Please provide an initial state")
            return False
        elif self.final_states == []:
            print("Please provide one or more final states")
            return False
        elif self.transitions == {}:
            print("Please provide one or more transitions")
            return False
        else:
            return True
    
    
    def run_fsa(self, inp = None):
        """
        Runs automaton on the provided input string. Ends if the automaton 
        does not have a start state, one or more final states and one or 
        more transitions, or if no input is given.  

        Parameters
        ----------
        inp : TYPE, optional
            DESCRIPTION. The default is None.

        Returns
        -------
        int
            -2 if the automaton is invalid or no input is given;
            -1 if input was not accepted by the automaton;
            0 if input was accepted.

        """
        if self.check_automaton() == False:
            print("Invalid automaton")
            return -2
        if inp is None:
            print("Please provide an input string")
            return -2
        
        print("Running automaton",self.name,"on input: ", inp)
        self.current_state = self.initial_state
        self.out=[]
        i = 0
        L = len(inp)
        #print(self.out)
        while i<L:
            cmd = inp[i]
            try:
                current_tr = self.transitions[(self.current_state, cmd)]
                i += 1
            except KeyError:
                #print("No transition is defined for state and input tuple: ", e)
                break
            #print(self.transitions[(self.current_state, cmd)])
            self.current_state = current_tr[0]
            self.out.append(current_tr[1])
            #print(self.out)
            
        print("the final state is: ",self.current_state)
        print("output: ", "".join(self.out))
        if (self.current_state in self.final_states) and (i == L):
            print("The automaton accepts this string")
            return 0
        else:
            print("The automaton does not accept this string")
            return -1

def from_txt_helper(automaton, file):
    """
    Helper function for fsa_from_txt and my_pda.pda_from_txt

    """
    with open(file) as f:
        states = f.readline().strip()
        states = states.split(",")
        #print(states)
        automaton.add_states(states)
        start = f.readline().strip()
        automaton.define_start(start)
        end = f.readline().strip().split(",")
        automaton.define_end(end)
    return automaton

def fsa_from_txt(file, name=""):
    """
    Builds a FSA from a configuration file in txt format, structured 
    as follows:
        first line: all the states separates by commas
        second line: initial state
        third line: final states separated by commas
        following lines: transitions with format: 
            start_state,input,end_state,output
    
    IMPORTANT: spaces are not stripped

    Parameters
    ----------
    file : string
        path to the .txt file.
    name : string, optional
        Nickname for the automaton. The default is "".

    Returns
    -------
    automaton : Fsa
        An object of class Fsa containing the automaton specified by the 
        states and transitions in the configuration file.

    """
    automaton = Fsa(name)
    automaton = from_txt_helper(automaton, file)
    with open(file) as f:
        for line in f.readlines()[3:]:
            tr = line.strip().split(",")
            automaton.add_transition(tr[0],tr[1],tr[2],tr[3])
        return automaton

